 Short, Self Contained, Correct (Compilable), Example (also known as an SSCCE).
Mutable states problems
    Error prone
    hard to reason
    hard to make concurrent
Higher Order Function means
we can pass Function to Function
we can create Function within Function
we can return Function from Function

Functions have to be pure, they don't have side effects
1. does not change anything
2. does not depend of anything that changes

Imperative vs Declarative
how             what
Mutate          transform
side-effects    pure
pass objects    pass Function also
hard to compose Functional composition

java -p => module path
java -f output/second.jar -d => will tell you the name

Everything in the class path goes for Unnamed module
Automatic module is old jar coming to life in module path
Explicitly named module are new stuff in the module path.- has module descriptor

if function is pure, compiler can use referencial transparancy ie. if a and b are final then usage of a + b can be
replaced by their values added, so runs faster

Builder pattern is also known as Train reck pattern or cascade pattern


there 5 types of lambda
static Integer::parseInt
bound the one capturing state eg. Instance.now()::isAfter
unbound String::toLowerCase
class constructor LinkedList::new
Array constructor int[]:: new

there are 43 standard function Interfaces
6 are basic.


parallelization is optimization, treat it like any other optimization

we don't come up with new things, we just come up with new names of same things and get very excited about it.
You can not learn an idiom by learning dictionary
idioms have a history, they have a story, and usage
Eg. rains cats and dogs

Concise
Highly Expressive


The Illitrates of the 21st centuary will not be those who can not read and write
but those who can not learn, unlearn and relearn = Alwin Toffler

i want to work in a company which creates environment which allows me to say I don't know
in a team that makes absolutely safe to be honest, for me to say i want to learn

Environment Shapes Behaviour


There are risks and costs to a program of action, but they are far less than the long-range risks and costs of
comfortable inaction - jFK

Design is good if its easier to change

YAGNI - You are not gonna Need it
    postpone things until they are really really needed

Cohesive code is narrow, focused, and does only one thing, hence changes less frequently
    Like things together, unlike things separate

Liskov's Substitution Principle
    use it only if there is substitutability
    Inheritance demands more from developers than Composition

Interface Segregation Principle
Clock implements TimeTeller, Alarm, Radio

so user one uses TimeTeller interface is only concerned about time details not Alarm or Radio

we are keeping interfaces separate for time, alarm, and radio

Functionl Programming = function composition and Lazy evaluation

Collectors mutablility is Local not shared hence safe



